\chapter{Implementation}

\section{Working with pointers in LLVM IR}

In LLVM IR, variables are created with an \verb!alloca! instruction, which returns a pointer to the allocated variable (which is allocated on the stack).
Therefore the line \verb!int a! in C is converted into \verb!%a = alloca i32! in LLVM IR.
It should be noted that the variable \verb!%a! is actually the type of \verb!i32*!.
This means that in the declaration \verb!int *a! will create in LLVM IR the variable \verb!%a! of type \verb!i32**!.

The \verb!store! instruction takes a piece of data and a pointer and stores the data in the area pointed to.
The following C code turns into the following LLVM code:

\begin{verbatim}
int a;
int b;
a = b;
\end{verbatim}

\begin{verbatim}
%a = alloca i32
%b = alloca i32
%1 = load i32* %b
store i32 %1, i32 %a
\end{verbatim}

Here, spaces on the stack for the variables \verb!a! and \verb!b! are created, and pointers to these spaces are stored in the variables \verb!%a! and \verb!%b! respectively.
The value stored in the area pointed to by \verb!%b! is loaded, and then stored in the area pointed to by the variable \verb!%a!.

\begin{verbatim}
int *c;
int d;
...
*c = d;
\end{verbatim}

\begin{verbatim}
%c = alloca i32*
%d = alloca i32
...
%1 = load i32** %c
%2 = load i32* %d
store i32 %2, i32* %c
\end{verbatim}

Here, in the C code we are assigning the value held in \verb!d! to the memory location pointed to by \verb!c! (assume that \verb!c! is set to a valid memory address during the \verb!...! otherwise the code results in undefined behaviour).

In LLVM IR, the variable \verb!%c! is created with type \verb!i32**! and the variable \verb!%d! is created with type \verb!i32*!.
The value stored in the memory pointed to by \verb!%c! is loaded into \verb!%1!, so \verb!%1! now contains the address pointed to by \verb!c! in the C code.
The value stored in the memory pointed to by \verb!%d! is loaded into \verb!%2! (the value contained within \verb!d! in the C code).
Finally the memory pointed to by \verb!%1! is set to the value contained in \verb!%2!.

The last interesting instruction for working with pointers is the GEP instruction.
GEP stands for 'Get Element Pointer', and is used for performing pointer arithmetic (it itself does not peform and memory access).

\begin{verbatim}
int *a, *b, *d;
int c;
a = b + 3;
c = d[3];
\end{verbatim}

\begin{verbatim}
%a = alloca i32*
%b = alloca i32*
%c = alloca i32
%d = alloca i32*

%1 = load i32** %b
%2 = getelementptr %1, i32 0, i32 3
store i32* %2, %a

%3 = load i32** %d
%4 = getelementptr %3, i32 0, i32 3
%5 = load i32* %4
store i32 %5, %c
\end{verbatim}

\verb!%1! contains the value of \verb!b! and the getelementptr is used for the pointer arithmetic.
The variable \verb!%1! is of type \verb!i32*!.
The second parameter of the GEP specifies how many of the size of the type of the first parameter we want to add.
In this case, and in most cases it is zero, saying that we don't want to add any of \verb!sizeof(i32*)! to the first parameter.
The third parameter specifies how many of the size of the type of the value contained within the first parameter we want to add, and in this case, we want to add \verb!3 * sizeof(i32)!.
Therefore the GEP returns:

\begin{verbatim}
%2 = %1 + 0 * sizeof(i32*) + 3 * sizeof(i32)
\end{verbatim}

This address is then stored in the memory pointed to by \verb!%a!.

The second operation can be rewritten as \verb!c = *(d + 3)!, so starts the same as the previous operation, except once the address of \verb!d+3! has been calculated, it is dereferenced to get the value contained there.

\section{Fat Pointers}
While a pointer contains an address to an area in memory, a fat pointer contains an address and additional information.
As implemented in Bandage, fat pointers contain three pointers, a value, a base and a bound.

\begin{verbatim}
int *x = malloc(5*sizeof(int));
x += 3;
\end{verbatim}

In bandage, the variable x, of type \verb!i32*! would be turned into a structure of type \verb!{i32*, i32*, i32*}!.
Assuming that malloc returned the address \verb!0x1000!, the variable x would contain \verb!{0x1000, 0x1000, 0x1020}! because it contains a pointer that currently points to \verb!0x1000! and whose valid addresses start at \verb!0x1000! inclusive and end at \verb!0x1020! not inclusive.
After the \verb!x += 3! instruction, the variable x would contain \verb!{0x1008, 0x1000, 0x1020}!.


Different pointer types give different fat pointer types.

\subsection{Pointers}
\subsection{Structs}
\subsubsection{Sizeof Woes}
\subsection{Functions}

\section{Lookup Table}

\section{CCured Analysis}

\section{Non-Null Analysis}
