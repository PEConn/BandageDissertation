\section{Pointer Safety}

One of the primary advantages of C is that it gives the programmer a model that is very close to hardware, allowing access to essentially arbitrary areas of memory.
Though this is very powerful, it can also be very dangerous and numerous security vulnerabilities have arisen from programmers not putting careful checks on their memory operations.

\subsection{Buffer Overflow Attack}

In a buffer overflow attack, the attacker makes use of the memory layout of the program to overwrite a variable that they should not have access to.

\begin{verbatim}
#include <stdio.h>
#include <string.h>

int main(void){
    char user[16];
    char pass[16];
    int userid = 0;

    printf("Username: ");
    gets(user);
    printf("Password: ");
    gets(pass);

    if(PasswordCorrect(user, pass))
        userid = GetUserId(user);

    if(userid == 0){
        printf("Invalid username or password.");
        return;
    }

    ...
}
\end{verbatim}

\begin{verbatim}
// In stdio
char *gets(char *buf)
{
    int c;
    char *s;

    for (s = buf; (c = getchar()) != '\n';)
        if (c == EOF)
            if (s == buf)
                return (NULL);
            else
                break;
        else
            *s++ = c;
    *s = 0;
    return (buf);
}
\end{verbatim}

\textbf{I need to touch up the style of verbatim a bit}

In this example, the main function simulates a login, the user is asked to enter a username and password, these are checked against each other, the user id is fetched and if \verb!userid! is still 0, they are kicked out as they have failed to log in.
The problem arises from the implementation of \verb!gets! (a simplified version taken from Apple's libc - the original version printed a warning notifying the user that \verb!gets! is unsafe).

The variable \verb!s! is set to point to the first byte of \verb!buf!, and for each character read in through \verb!getchar! that isn't a newline or end-of-file, the memory location pointed to by \verb!s! is set to that character and \verb!s! is incremented.
The problem here is that there is no bounds checking performed on \verb!s!.

The attack occurs as follows:

\begin{itemize}
\item The attacker provides a password that is longer than 16 characters.
\item \verb!gets! is called, with \verb!pass! being passed in as the argument.
\item The for loop continues until a newline in countered, in this case continuing to write past the memory allocated for \verb!pass!.
\item \verb!userid! is positioned in memory after the end of \verb!pass!, so when \verb!gets! writes past the end of \verb!pass!, it overwrites the value of \verb!userid!.
\item \verb!userid!, which was originally set to zero, and assumed by the programmer to be unchanged unless the password and username match, has been checked to a non-zero value.
\item The attacker is given a valid \verb!userid!, and can even set the userid to be whatever they want to be by varying the 17th character of the input password.
\end{itemize}

\subsection{Heartbleed}

A more topical example is the Heartbleed vulnerability found in the OpenSSL library - an open source implementation of the SSL and TLS protocols.
The vulnerability, found in April 2014 is the opposite of a buffer overflow.
Where, in a buffer overflow the attacker can write past the allocated memory to overwrite other values, the heartbleed bug allows the attacker to read past the memory allocated for the legitimate information and read values stored in RAM (such as passwords and private keys).


\begin{verbatim}
/* Read type and payload length first */
hbtype = *p++;
n2s(p, payload);
pl = p;
...
unsigned char *buffer, *bp;
int r;

buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
...
/* Enter response type, length and copy payload */
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
\end{verbatim}

The variable \verb!p! points to a \verb!ssl3_record_st!, the incoming message.
The first byte of the message is read (the type of the record) and is stored in \verb!bhtype!, and then the \verb!n2s! macro takes two bytes from \verb!p! and stores them in the variable \verb!payload!, which is designed to contain the length of the message.
Finally, \verb!pl! is set to contain the rest of the received message.
Note that the received message is received from a potentially untrusted source.

A buffer is created and has \verb!1 + 2 + payload + padding! allocated for it.

The response message is created in \verb!bp! and its first byte (its record type) being set to \verb!TLS1_HB_RESPONSE!, and with the macro \verb!s2n! copying two bytes from \verb!payload! into \verb!bp!.
Finally, \verb!memcpy! is called, which copies \verb!payload! bytes of \verb!pl! into \verb!bp!.
This was originally intended to copy the rest of the heartbeat message back into the response but is the line that introduces the vulnerability.

The bug comes into play when the variable \verb!payload!, originally extracted from the adversary originating message specifies a size bigger than the rest of the package.
\verb!memcpy! will copy past the end of the legitimate data stored in \verb!pl! and start copying bytes into \verb!bp! of other variables and essentially whatever happens to be sitting in RAM nearby \verb!pl! at the time.
Finally \verb!bp! is sent back to the adversary.


\section{Spatial and Temporal Pointer Safety}

There are two types of safety that can be provided when dealing with pointers - temporal and spatial.
Temporal safety ensures that the pointer points to a valid area of memory at the time that it is dereferenced, while spatial safety just ensures that the pointer points to a valid area of memory at a certain time.

The methods explored in this dissertation provide spatial safety, but not complete temporal safety.
Consider the following code:

\begin{verbatim}
int *a=malloc(sizeof(int));
int *b=a;

free(a);

printf("%d\n", *a);
printf("%d\n", *b);
\end{verbatim}

The methods implemented in this dissertation will catch the memory access error introduced by the first \verb!printf! statement, but not by the second.
This is because the information about pointer validity is associated with the pointer, and so when \verb!a! is freed the information associated with it indicates that it does not point to valid memory, but the information associated with \verb!b! is not likewise updated.`

Therefore the techniques implemented in this dissertation do not provide complete pointer safety, but provide an additional layer of robustness.

\section{Working with Pointers in LLVM IR}

During this chapter, types will be referred to in LLVM notation.
An \verb!i32! stands for a 32-bit integer, a \verb!i8! stands for an 8 bit integer (or char) and a pointer to a type is denoted by the type followed by an asterisk.

In LLVM IR, space on the stack is set aside with the \verb!alloca! instruction, which returns a pointer to the allocated memory.
Therefore the line \verb!int a! in C is converted into \verb!%a = alloca i32! in LLVM IR.
It should be noted that the variable \verb!%a! is actually the type of \verb!i32*!.
This means that in the declaration \verb!int *a! will create in LLVM IR the variable \verb!%a! of type \verb!i32**!.

The \verb!store! instruction takes a piece of data and a pointer and stores the data in the area pointed to.
The following C code turns into the following LLVM code:

\begin{verbatim}
int a;
int b;
a = b;
\end{verbatim}

\begin{verbatim}
%a = alloca i32
%b = alloca i32
%1 = load i32* %b
store i32 %1, i32 %a
\end{verbatim}

Here, spaces on the stack for the variables \verb!a! and \verb!b! are created, and pointers to these spaces are stored in the variables \verb!%a! and \verb!%b! respectively.
The value stored in the area pointed to by \verb!%b! is loaded, and then stored in the area pointed to by the variable \verb!%a!.

\begin{verbatim}
int *c;
int d;
...
*c = d;
\end{verbatim}

\begin{verbatim}
%c = alloca i32*
%d = alloca i32
...
%1 = load i32** %c
%2 = load i32* %d
store i32 %2, i32* %c
\end{verbatim}

Here, in the C code we are assigning the value held in \verb!d! to the memory location pointed to by \verb!c! (assume that \verb!c! is set to a valid memory address during the \verb!...! otherwise the code results in undefined behaviour).

In LLVM IR, the variable \verb!%c! is created with type \verb!i32**! and the variable \verb!%d! is created with type \verb!i32*!.
The value stored in the memory pointed to by \verb!%c! is loaded into \verb!%1!, so \verb!%1! now contains the address pointed to by \verb!c! in the C code.
The value stored in the memory pointed to by \verb!%d! is loaded into \verb!%2! (the value contained within \verb!d! in the C code).
Finally the memory pointed to by \verb!%1! is set to the value contained in \verb!%2!.

The last interesting instruction for working with pointers is the GEP instruction.
GEP stands for 'Get Element Pointer', and is used for performing pointer arithmetic (it itself does not peform and memory access).

\begin{verbatim}
int *a, *b, *d;
int c;
a = b + 3;
c = d[3];
\end{verbatim}

\begin{verbatim}
%a = alloca i32*
%b = alloca i32*
%c = alloca i32
%d = alloca i32*

%1 = load i32** %b
%2 = getelementptr %1, i32 0, i32 3
store i32* %2, %a

%3 = load i32** %d
%4 = getelementptr %3, i32 0, i32 3
%5 = load i32* %4
store i32 %5, %c
\end{verbatim}

\verb!%1! contains the value of \verb!b! and the getelementptr is used for the pointer arithmetic.
The variable \verb!%1! is of type \verb!i32*!.
The second parameter of the GEP specifies how many of the size of the type of the first parameter we want to add.
In this case, and in most cases it is zero, saying that we don't want to add any of \verb!sizeof(i32*)! to the first parameter.
The third parameter specifies how many of the size of the type of the value contained within the first parameter we want to add, and in this case, we want to add \verb!3 * sizeof(i32)!.
Therefore the GEP returns:

\begin{verbatim}
%2 = %1 + 0 * sizeof(i32*) + 3 * sizeof(i32)
\end{verbatim}

This address is then stored in the memory pointed to by \verb!%a!.

The second operation can be rewritten as \verb!c = *(d + 3)!, so starts the same as the previous operation, except once the address of \verb!d+3! has been calculated, it is dereferenced to get the value contained there.

