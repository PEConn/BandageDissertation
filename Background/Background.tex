\chapter{Background}

\section{Pointer Safety}

Playing with raw pointers gives power, but is dangerous. Leads to security holes. Example of buffer overflow attack.

\section{Spatial and Temporal Pointer Safety}

There are two types of safety that can be provided when dealing with pointers - temporal and spatial.
Temporal safety ensures that the pointer points to a valid area of memory at the time that it is dereferenced, while spatial safety just ensures that the pointer points to a valid area of memory at a certain time.

The methods explored in this dissertation provide spatial safety, but not complete temporal safety.
Consider the following code:

\begin{verbatim}
int *a=malloc(sizeof(int));
int *b=a;

free(a);

printf("%d\n", *a);
printf("%d\n", *b);
\end{verbatim}

The methods implemented in this dissertation will catch the memory access error introduced by the first \verb!printf! statement, but not by the second.
This is because the information about pointer validity is associated with the pointer, and so when \verb!a! is freed the information associated with it indicates that it does not point to valid memory, but the information associated with \verb!b! is not likewise updated.`

Therefore the techniques implemented in this dissertation do not provide complete pointer safety, but provide an additional layer of robustness.

\section{Literature Review}

Give a brief summary of the ~25 papers I did in the literature review, talking about their approaches to pointer safety and going into the classifications: fat pointers/ metadata and object-based vs pointer-based approaches.

\section{Relation to Work Done}

During the course of this project, two different LLVM transformation passes were developed.
The first uses a fat pointer representation to keep track of the base and bounds information for allocated memory areas, whereas the second keeps this data separate from the pointers themselves.

Therefore, both approaches described in this dissertation use the same method for ensuring temporal pointer safety - checking of base and bounds.
However the way they store the bounds information is different.

This should result in similar strengths and failings in terms of capability (what violations are caught), but different trade-offs in terms of performance.


\textbf{Check I've got the terminology right here}

\section{CCured Analysis}

CCured designates pointer as one of three types: \textit{SAFE}, \textit{SEQ} and \textit{DYNAMIC}.
\textbf{Explain what each of these mean}
While the CCured language itself has pointers explicitly marked as one of these types, its main goal is to allow the use of CCured with existing unmodified C programs and it uses a type inference algorithm to do so.

Every pointer is annotated with a *qualifier variable*, which is one of the three above types.
We'll use $Q(a)$ to mean the qualifier variable of $a$ and $T(a)$ to mean the type pointed to by $a$.
These can be recursive, with the type pointed to by $a$ being a pointer itself, for example $a$ could be of type $int\; \mbox{ref}\; SAFE\; \mbox{ref}\; SAFE$, in which case $T(a) = int\;\mbox{ref}\;SAFE$.

\subsection{CCured Constraint Collection}

There are three operations that generate constraints in a C program, these are arithmetic, casting and assignment.

Arithmetic is the simplest one of these, and says that if a pointer has arithmetic performed on it, it cannot be \textit{SAFE}.

\begin{verbatim}
int *a;
int *b;

a = b + 4;
\end{verbatim}

Two constraints are generated here, one from the arithmetic and one from the assignment.
The arithmetic constraint marks the pointer that has arithmetic performed on it, so in this case, $Q(b) != SAFE$.

Assignment is slightly more complicated, the assignment \verb|a = b| generates the following contraints if both a and b are pointers:

\begin{verbatim}
Q(a) = Q(b) = DYNQ 
\/ (
       (Q(a) = Q(b) = SAFE 
       \/ Q(a) = Q(b) = SEQ
       \/ Q(a) = SAFE /\ Q(b) = SEQ) 
    \/ T(a) = T(b)
)
\end{verbatim}

The first line is a provision that a \textit{DYNAMIC} pointer can be set to a \textit{DYNAMIC} pointer regardless of the types.

The remaining lines allow the matching up of qualifiers given if the types pointed to are equal.
A \textit{SAFE} pointer can be set to a \textit{SAFE} pointer, a \textit{SEQ} pointer can be set to a \textit{SEQ} pointer and a \textit{SAFE} pointer can be set to a \textit{SEQ} pointer.
In the last case, a bounds check is performed to ensure the safe pointer is set to a value within the bounds of the sequential pointer.
After the assignment, the safe pointer contains no further bounds information.

One final case exists for the assignment of \verb|a = b|, where $b$ is an integer and $b$ is a pointer.
In this case, the only constraint generated is $Q(e) != SAFE$.

Similar constraints are generated on a cast.

After the source code is iterated through and all of the constraints are generated, a constraint solver is run and the qualifiers for all variables.

%\section{Cyclone Not-Null pointers}

%In the CCured system, even \textit{SAFE} pointers must undergo null checks on dereference.
%The Cyclone dialect of C contains the notion of a not-NULL pointer - one that can never hold the value NULL.
