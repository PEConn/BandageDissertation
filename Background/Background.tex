\section{Pointer Safety}

Playing with raw pointers gives power, but is dangerous. Leads to security holes. Example of buffer overflow attack.

\section{Spatial and Temporal Pointer Safety}

There are two types of safety that can be provided when dealing with pointers - temporal and spatial.
Temporal safety ensures that the pointer points to a valid area of memory at the time that it is dereferenced, while spatial safety just ensures that the pointer points to a valid area of memory at a certain time.

The methods explored in this dissertation provide spatial safety, but not complete temporal safety.
Consider the following code:

\begin{verbatim}
int *a=malloc(sizeof(int));
int *b=a;

free(a);

printf("%d\n", *a);
printf("%d\n", *b);
\end{verbatim}

The methods implemented in this dissertation will catch the memory access error introduced by the first \verb!printf! statement, but not by the second.
This is because the information about pointer validity is associated with the pointer, and so when \verb!a! is freed the information associated with it indicates that it does not point to valid memory, but the information associated with \verb!b! is not likewise updated.`

Therefore the techniques implemented in this dissertation do not provide complete pointer safety, but provide an additional layer of robustness.

\section{Working with Pointers in LLVM IR}

During this chapter, types will be referred to in LLVM notation.
An \verb!i32! stands for a 32-bit integer, a \verb!i8! stands for an 8 bit integer (or char) and a pointer to a type is denoted by the type followed by an asterisk.

In LLVM IR, space on the stack is set aside with the \verb!alloca! instruction, which returns a pointer to the allocated memory.
Therefore the line \verb!int a! in C is converted into \verb!%a = alloca i32! in LLVM IR.
It should be noted that the variable \verb!%a! is actually the type of \verb!i32*!.
This means that in the declaration \verb!int *a! will create in LLVM IR the variable \verb!%a! of type \verb!i32**!.

The \verb!store! instruction takes a piece of data and a pointer and stores the data in the area pointed to.
The following C code turns into the following LLVM code:

\begin{verbatim}
int a;
int b;
a = b;
\end{verbatim}

\begin{verbatim}
%a = alloca i32
%b = alloca i32
%1 = load i32* %b
store i32 %1, i32 %a
\end{verbatim}

Here, spaces on the stack for the variables \verb!a! and \verb!b! are created, and pointers to these spaces are stored in the variables \verb!%a! and \verb!%b! respectively.
The value stored in the area pointed to by \verb!%b! is loaded, and then stored in the area pointed to by the variable \verb!%a!.

\begin{verbatim}
int *c;
int d;
...
*c = d;
\end{verbatim}

\begin{verbatim}
%c = alloca i32*
%d = alloca i32
...
%1 = load i32** %c
%2 = load i32* %d
store i32 %2, i32* %c
\end{verbatim}

Here, in the C code we are assigning the value held in \verb!d! to the memory location pointed to by \verb!c! (assume that \verb!c! is set to a valid memory address during the \verb!...! otherwise the code results in undefined behaviour).

In LLVM IR, the variable \verb!%c! is created with type \verb!i32**! and the variable \verb!%d! is created with type \verb!i32*!.
The value stored in the memory pointed to by \verb!%c! is loaded into \verb!%1!, so \verb!%1! now contains the address pointed to by \verb!c! in the C code.
The value stored in the memory pointed to by \verb!%d! is loaded into \verb!%2! (the value contained within \verb!d! in the C code).
Finally the memory pointed to by \verb!%1! is set to the value contained in \verb!%2!.

The last interesting instruction for working with pointers is the GEP instruction.
GEP stands for 'Get Element Pointer', and is used for performing pointer arithmetic (it itself does not peform and memory access).

\begin{verbatim}
int *a, *b, *d;
int c;
a = b + 3;
c = d[3];
\end{verbatim}

\begin{verbatim}
%a = alloca i32*
%b = alloca i32*
%c = alloca i32
%d = alloca i32*

%1 = load i32** %b
%2 = getelementptr %1, i32 0, i32 3
store i32* %2, %a

%3 = load i32** %d
%4 = getelementptr %3, i32 0, i32 3
%5 = load i32* %4
store i32 %5, %c
\end{verbatim}

\verb!%1! contains the value of \verb!b! and the getelementptr is used for the pointer arithmetic.
The variable \verb!%1! is of type \verb!i32*!.
The second parameter of the GEP specifies how many of the size of the type of the first parameter we want to add.
In this case, and in most cases it is zero, saying that we don't want to add any of \verb!sizeof(i32*)! to the first parameter.
The third parameter specifies how many of the size of the type of the value contained within the first parameter we want to add, and in this case, we want to add \verb!3 * sizeof(i32)!.
Therefore the GEP returns:

\begin{verbatim}
%2 = %1 + 0 * sizeof(i32*) + 3 * sizeof(i32)
\end{verbatim}

This address is then stored in the memory pointed to by \verb!%a!.

The second operation can be rewritten as \verb!c = *(d + 3)!, so starts the same as the previous operation, except once the address of \verb!d+3! has been calculated, it is dereferenced to get the value contained there.

