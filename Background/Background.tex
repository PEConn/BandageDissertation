\chapter{Background}

\section{Pointer Safety}

Playing with raw pointers gives power, but is dangerous. Leads to security holes. Example of buffer overflow attack.

\section{Literature Review}

Give a brief summary of the ~25 papers I did in the literature review, talking about their approaches to pointer safety and going into the classifications: fat pointers/ metadata and object-based vs pointer-based approaches.

\section{CCured Analysis}

CCured designates pointer as one of three types: \textit{SAFE}, \textit{SEQ} and \textit{DYNAMIC}.
\textbf{Explain what each of these mean}
While the CCured language itself has pointers explicitly marked as one of these types, its main goal is to allow the use of CCured with existing unmodified C programs and it uses a type inference algorithm to do so.

Every pointer is annotated with a *qualifier variable*, which is one of the three above types.
We'll use $Q(a)$ to mean the qualifier variable of $a$ and $T(a)$ to mean the type pointed to by $a$.
These can be recursive, with the type pointed to by $a$ being a pointer itself, for example $a$ could be of type $int\; \mbox{ref}\; SAFE\; \mbox{ref}\; SAFE$, in which case $T(a) = int\;\mbox{ref}\;SAFE$.

\subsection{CCured Constraint Collection}

There are three operations that generate constraints in a C program, these are arithmetic, casting and assignment.

Arithmetic is the simplest one of these, and says that if a pointer has arithmetic performed on it, it cannot be \textit{SAFE}.

\begin{verbatim}
int *a;
int *b;

a = b + 4;
\end{verbatim}

Two constraints are generated here, one from the arithmetic and one from the assignment.
The arithmetic constraint marks the pointer that has arithmetic performed on it, so in this case, $Q(b) != SAFE$.

Assignment is slightly more complicated, the assignment \verb|a = b| generates the following contraints if both a and b are pointers:

\begin{verbatim}
Q(a) = Q(b) = DYNQ 
\/ (
       (Q(a) = Q(b) = SAFE 
       \/ Q(a) = Q(b) = SEQ
       \/ Q(a) = SAFE /\ Q(b) = SEQ) 
    \/ T(a) = T(b)
)
\end{verbatim}

The first line is a provision that a \textit{DYNAMIC} pointer can be set to a \textit{DYNAMIC} pointer regardless of the types.

The remaining lines allow the matching up of qualifiers given if the types pointed to are equal.
A \textit{SAFE} pointer can be set to a \textit{SAFE} pointer, a \textit{SEQ} pointer can be set to a \textit{SEQ} pointer and a \textit{SAFE} pointer can be set to a \textit{SEQ} pointer.
In the last case, a bounds check is performed to ensure the safe pointer is set to a value within the bounds of the sequential pointer.
After the assignment, the safe pointer contains no further bounds information.

One final case exists for the assignment of \verb|a = b|, where $b$ is an integer and $b$ is a pointer.
In this case, the only constraint generated is $Q(e) != SAFE$.

Similar constraints are generated on a cast.

After the source code is iterated through and all of the constraints are generated, a constraint solver is run and the qualifiers for all variables.

\section{Cyclone Not-Null pointers}

In the CCured system, even \textit{SAFE} pointers must undergo null checks on dereference.
The Cyclone dialect of C contains the notion of a not-NULL pointer - one that can never hold the value NULL.
